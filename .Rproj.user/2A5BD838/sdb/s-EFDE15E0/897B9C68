{
    "collab_server" : "",
    "contents" : "library(httr)\nlibrary(XML)\n### Function from 'rsnp' package\n### https://github.com/ropensci/rsnps/blob/master/R/NCBI_snp_query.R\n#' Query NCBI's dbSNP for information on a set of SNPs\n#'\n#' This function queries NCBI's dbSNP for information related to the latest\n#' dbSNP build and latest reference genome for information on the vector\n#' of SNPs submitted.\n#'\n#' @param SNPs A vector of SNPs (rs numbers).\n#' @param ... Further named parameters passed on to \\code{\\link[httr]{config}} \n#' to debug curl. See examples.\n#' @export\n#' @return A dataframe with columns:\n#' \\itemize{\n#' \\item \\code{Query:} The rs ID that was queried.\n#' \\item \\code{Chromosome:} The chromosome that the marker lies on.\n#' \\item \\code{Marker:} The name of the marker. If the rs ID queried\n#' has been merged, the up-to-date name of the marker is returned here, and\n#' a warning is issued.\n#' \\item \\code{Class:} The marker's 'class'. See\n#' \\url{http://www.ncbi.nlm.nih.gov/projects/SNP/snp_legend.cgi?legend=snpClass}\n#' for more details.\n#' \\item \\code{Gene:} If the marker lies within a gene (either within the exon\n#' or introns of a gene), the name of that gene is returned here; otherwise,\n#' \\code{NA}. Note that\n#' the gene may not be returned if the marker lies too far upstream or downstream\n#' of the particular gene of interest.\n#' \\item \\code{Alleles:} The alleles associated with the SNP if it is a\n#' SNV; otherwise, if it is an INDEL, microsatellite, or other kind of\n#' polymorphism the relevant information will be available here.\n#' \\item \\code{Major:} The major allele of the SNP, on the forward strand,\n#' given it is an SNV; otherwise, \\code{NA}.\n#' \\item \\code{Minor:} The minor allele of the SNP, on the forward strand,\n#' given it is an SNV; otherwise, \\code{NA}.\n#' \\item \\code{MAF:} The minor allele frequency of the SNP, given it is an SNV.\n#' This is drawn from the current global reference population used by NCBI.\n#' \\item \\code{BP:} The chromosomal position, in base pairs, of the marker,\n#' as aligned with the current genome used by dbSNP. we add 1 to the base \n#' pair position in the BP column in the output data.frame to agree with \n#' what the dBSNP website has.\n#' }\n#' \n#' @note \\code{ncbi_snp_query} is a synonym of \\code{NCBI_snp_query} - we'll \n#' make \\code{NCBI_snp_query} defunct in the next version\n#' \n#' @seealso \\code{\\link{ncbi_snp_query2}}\n#' \n#' @references \\url{https://www.ncbi.nlm.nih.gov/projects/SNP/}\n#' \n#' @details Note that you are limited in the number of SNPs you pass in to one \n#' request because URLs can only be so long. Around 600 is likely the max you \n#' can pass in, though may be somewhat more. Break up your vector of SNP \n#' codes into pieces of 600 or less and do repeated requests to get all data.\n#' \n#' @examples \\dontrun{\n#' ## an example with both merged SNPs, non-SNV SNPs, regular SNPs,\n#' ## SNPs not found, microsatellite\n#' SNPs <- c(\"rs332\", \"rs420358\", \"rs1837253\", \"rs1209415715\", \"rs111068718\")\n#' ncbi_snp_query(SNPs)\n#' # ncbi_snp_query(\"123456\") ##invalid: must prefix with 'rs'\n#' ncbi_snp_query(\"rs420358\")\n#' ncbi_snp_query(\"rs332\") # warning that its merged into another, try that\n#' ncbi_snp_query(\"rs121909001\")\n#' ncbi_snp_query(\"rs1837253\")\n#' # warning that no data available, returns 0 length data.frame\n#' ncbi_snp_query(\"rs1209415715\")\n#' # warning that chromosomal information may be unmapped \n#' ncbi_snp_query(\"rs111068718\") \n#'\n#' ncbi_snp_query(SNPs='rs9970807')$BP\n#'\n#' # Curl debugging\n#' ncbi_snp_query(\"rs121909001\")\n#' library(\"httr\")\n#' ncbi_snp_query(\"rs121909001\", config=verbose())\n#' snps <- c(\"rs332\", \"rs420358\", \"rs1837253\", \"rs1209415715\", \"rs111068718\")\n#' ncbi_snp_query(snps, config=progress())\n#' }\nNCBI_snp_query <- function(SNPs, ...) {\n  if (grepl(\"NCBI\", deparse(sys.call()))) {\n    .Deprecated(\"ncbi_snp_query\", package = \"rsnps\", \n                \"use ncbi_snp_query instead - NCBI_snp_query removed in next version\")\n  }\n  \n  ## ensure these are rs numbers of the form rs[0-9]+\n  tmp <- sapply( SNPs, function(x) { grep( \"^rs[0-9]+$\", x) } )\n  if (any(sapply( tmp, length ) == 0)) {\n    stop(\"not all items supplied are prefixed with 'rs';\\n\",\n         \"you must supply rs numbers and they should be prefixed with \",\n         \"'rs', e.g. rs420358\", call. = FALSE)\n  }\n  \n  url <- \"https://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi\"\n  res <- GET(url, query = list(db = 'snp', mode = 'xml', \n                               id = paste( SNPs, collapse = \",\")), ...)\n  stop_for_status(res)\n  xml <- cuf8(res)\n  xml_parsed <- xmlInternalTreeParse( xml )\n  xml_list_ <- xmlToList( xml_parsed )\n  \n  ## we don't need the last element; it's just metadata\n  xml_list <- xml_list_[ 1:(length(xml_list_) - 1) ]\n  \n  ## Check which rs numbers were found, and warn if one was not found\n  ## one thing that makes our life difficult: there can be multiple\n  ## XML entries with the same name. make sure we go through all of them\n  found_snps <- unname( unlist( sapply( xml_list, function(x) {\n    \n    ## check if the SNP is either in the current rsId, or the merged SNP list\n    attr_rsIds <- tryget( x$.attrs[\"rsId\"] )\n    \n    merge_indices <- which( names(x) == \"MergeHistory\" )\n    if (length(merge_indices)) {\n      merge_rsIds <- sapply(x[merge_indices], \"[[\", \"rsId\")\n    } else {\n      merge_rsIds <- NULL\n    }\n    \n    possible_names <- c(attr_rsIds, merge_rsIds)\n    return(possible_names)\n    \n  }) ) )\n  \n  found_snps <- found_snps[ !is.na(found_snps) ]\n  found_snps <- paste(sep = '', \"rs\", found_snps)\n  \n  if (any(!(SNPs %in% found_snps))) {\n    warning(\"The following rsIds had no information available on NCBI:\\n  \",\n            paste( SNPs[ !(SNPs %in% found_snps) ], collapse = \", \"),\n            call. = FALSE)\n  }\n  SNPs <- SNPs[ SNPs %in% found_snps ]\n  \n  out <- as.data.frame(matrix(0, nrow = length(SNPs), ncol = 11))\n  names(out) <- c(\"Query\", \"Chromosome\", \"Marker\", \"Class\", \"Gene\", \"Alleles\",\n                  \"Major\", \"Minor\", \"MAF\", \"BP\", \"AncestralAllele\")\n  \n  for (i in seq_along(SNPs)) {\n    my_list <- xml_list[[i]]\n    my_chr <- tryget(my_list$Assembly$Component$.attrs[\"chromosome\"])\n    if (is.null(my_chr)) {\n      my_chr <- NA\n      warning(\"No chromosomal information for \", SNPs[i], \"; may be unmapped\", \n              call. = FALSE)\n    }\n    my_snp <- tryget( my_list$.attrs[\"rsId\"] )\n    if ( !is.na(my_snp) ) {\n      my_snp <- paste(sep = '', \"rs\", my_snp)\n    }\n    if (my_snp != SNPs[i] ) {\n      warning(SNPs[i], \" has been merged into \", my_snp, call. = FALSE)\n    }\n    my_snpClass <- tryget(my_list$.attrs[\"snpClass\"])\n    \n    my_gene <- tryget( my_list$Assembly$Component$MapLoc$FxnSet['symbol'] )\n    if (is.null(my_gene)) my_gene <- NA\n    alleles <- my_list$Ss$Sequence$Observed\n    \n    ## handle true SNPs\n    if (my_snpClass %in% c(\"snp\", \"snv\")) {\n      tmp <- c( my_list$Ss$Sequence$Observed, my_list$Ss$.attrs[\"orient\"] )\n      if (tmp[2] != \"forward\") {\n        tmp[1] <- flip( tmp[1], sep = \"/\" )\n      }\n      alleles_split <- strsplit( tmp[1], \"/\" )[[1]]\n      \n      ## check which of the two alleles grabbed is actually the minor allele\n      ## we might have to 'flip' the minor allele if there is no match\n      maf_allele <- my_list$Frequency['allele']\n      if (is.null(maf_allele)) {\n        maf_allele <- alleles <- strsplit(my_list$Sequence$Observed, \"/\")[[1]]\n        my_major <- alleles[1]\n        my_minor <- alleles[2]\n        my_freq <- NA\n      } else {\n        my_minor <- alleles_split[ maf_allele == alleles_split ]\n        my_major <- alleles_split[ maf_allele != alleles_split ]\n        my_freq <- my_list$Frequency[\"freq\"]\n      }\n      if (all(maf_allele != alleles_split) ) {\n        maf_allele <- swap( maf_allele, c(\"A\", \"C\", \"G\", \"T\"), c(\"T\", \"G\", \"C\", \"A\") )\n      }\n      \n    } else { \n      ## handle the others in a generic way; maybe specialize later\n      my_minor <- NA\n      my_major <- NA\n      my_freq <- NA\n    }\n    \n    my_pos <- tryCatch(\n      my_list$Assembly$Component$MapLoc$.attrs[\"physMapInt\"],\n      error = function(e) {\n        my_list$Assembly$Component$MapLoc[\"physMapInt\"]\n      }\n    )\n    \n    if (is.null(my_pos)) my_pos <- NA\n    \n    # Based one NCBI's response, the position data in their XML API output \n    # should be off by one when compared to web display. So we add one here\n    # to make them equivalent \n    #if (is.numeric(my_pos)) my_pos <- my_pos + 1\n    my_pos <- as.integer(my_pos) + 1\n    \n    # Ancestral Allele\n    anc_all <- my_list$Sequence$.attrs['ancestralAllele']\n    anc_all <- if (is.na(anc_all)) NA else anc_all[[1]]\n    \n    out[i, ] <- c(\n      SNPs[i], my_chr, my_snp, unname(my_snpClass),\n      unname(my_gene), paste0(unname(alleles), collapse = \",\"), \n      unname(my_major), unname(my_minor),\n      as.numeric(my_freq), as.integer(my_pos),\n      anc_all\n    )\n    \n  }\n  \n  for (nm in c(\"MAF\", \"BP\")) {\n    out[, nm] <- as.numeric( out[, nm] )\n  }\n  \n  return(out)\n  \n  ## NCBI limits to a maximum of 1 query per three seconds; we\n  ## ensure that this limit is adhered to\n  Sys.sleep(3)\n}\n\n#' @export\n#' @rdname NCBI_snp_query\nncbi_snp_query <- NCBI_snp_query\n\ncuf8 <- function(x) httr::content(x, \"text\", encoding = \"UTF-8\")",
    "created" : 1507685832773.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "147598059",
    "id" : "897B9C68",
    "lastKnownWriteTime" : 1507686470,
    "last_content_update" : 1507686470127,
    "path" : "~/Documents/NGSProject/2017WGS/R/GeneGeneInteraction_HSCT/utils/NCBI_snp_query.R",
    "project_path" : "utils/NCBI_snp_query.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}